[
  {
    "id": 1,
    "type": "regex_matching",
    "answer": "**正则表达式：**\n```regex\n[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\n```\n\n**匹配的邮件地址：**\n1. admin@example.com\n2. support@test.org  \n3. contact123@company.cn\n\n**正则表达式解释：**\n- `[a-zA-Z0-9._%+-]+`：匹配用户名部分，包含字母、数字、点、下划线、百分号、加号、减号，至少一个字符\n- `@`：匹配@符号\n- `[a-zA-Z0-9.-]+`：匹配域名部分，包含字母、数字、点、减号，至少一个字符\n- `\\.`：匹配点号（需要转义）\n- `[a-zA-Z]{2,}`：匹配顶级域名，至少2个字母\n\n**Python实现示例：**\n```python\nimport re\n\ntext = \"请联系我们：admin@example.com，技术支持：support@test.org，或者发送邮件到 contact123@company.cn。无效格式：admin@、@example.com、test@。\"\npattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}'\nemails = re.findall(pattern, text)\nprint(\"找到的邮件地址：\", emails)\n```",
    "content": "**正则表达式：**\n```regex\n[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\n```\n\n**匹配的邮件地址：**\n1. admin@example.com\n2. support@test.org  \n3. contact123@company.cn\n\n**正则表达式解释：**\n- `[a-zA-Z0-9._%+-]+`：匹配用户名部分，包含字母、数字、点、下划线、百分号、加号、减号，至少一个字符\n- `@`：匹配@符号\n- `[a-zA-Z0-9.-]+`：匹配域名部分，包含字母、数字、点、减号，至少一个字符\n- `\\.`：匹配点号（需要转义）\n- `[a-zA-Z]{2,}`：匹配顶级域名，至少2个字母\n\n**Python实现示例：**\n```python\nimport re\n\ntext = \"请联系我们：admin@example.com，技术支持：support@test.org，或者发送邮件到 contact123@company.cn。无效格式：admin@、@example.com、test@。\"\npattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}'\nemails = re.findall(pattern, text)\nprint(\"找到的邮件地址：\", emails)\n```"
  },
  {
    "id": 2,
    "type": "code_debugging", 
    "answer": "**错误分析：**\n\n1. **语法错误**：第4行 `if num % 2 = 0:` 使用了赋值操作符 `=`，应该使用比较操作符 `==`\n\n**修正后的代码：**\n```python\ndef sum_of_even_squares(numbers):\n    \"\"\"计算列表中所有偶数的平方和\"\"\"\n    total = 0\n    for num in numbers:\n        if num % 2 == 0:  # 检查是否为偶数（修正：使用==比较）\n            total += num ** 2\n    return total\n\n# 测试\nnumbers = [1, 2, 3, 4, 5, 6]\nresult = sum_of_even_squares(numbers)\nprint(f\"偶数平方和：{result}\")\n# 输出：偶数平方和：56 (2²+4²+6² = 4+16+36 = 56)\n```\n\n**修正原因：**\n- Python中 `=` 是赋值操作符，用于给变量赋值\n- `==` 是比较操作符，用于判断两个值是否相等\n- 在条件判断中必须使用 `==` 来比较值\n\n**验证结果：**\n- 偶数：2, 4, 6\n- 平方：4, 16, 36  \n- 总和：4 + 16 + 36 = 56 ✓",
    "content": "**错误分析：**\n\n1. **语法错误**：第4行 `if num % 2 = 0:` 使用了赋值操作符 `=`，应该使用比较操作符 `==`\n\n**修正后的代码：**\n```python\ndef sum_of_even_squares(numbers):\n    \"\"\"计算列表中所有偶数的平方和\"\"\"\n    total = 0\n    for num in numbers:\n        if num % 2 == 0:  # 检查是否为偶数（修正：使用==比较）\n            total += num ** 2\n    return total\n\n# 测试\nnumbers = [1, 2, 3, 4, 5, 6]\nresult = sum_of_even_squares(numbers)\nprint(f\"偶数平方和：{result}\")\n# 输出：偶数平方和：56 (2²+4²+6² = 4+16+36 = 56)\n```\n\n**修正原因：**\n- Python中 `=` 是赋值操作符，用于给变量赋值\n- `==` 是比较操作符，用于判断两个值是否相等\n- 在条件判断中必须使用 `==` 来比较值\n\n**验证结果：**\n- 偶数：2, 4, 6\n- 平方：4, 16, 36  \n- 总和：4 + 16 + 36 = 56 ✓"
  },
  {
    "id": 3,
    "type": "algorithm_problem",
    "answer": "**算法实现：**\n\n```python\ndef maxAreaOfIsland(grid):\n    \"\"\"\n    计算二维网格中最大岛屿的面积\n    \n    Args:\n        grid: 二维字符数组，'1'表示陆地，'0'表示水域\n    \n    Returns:\n        int: 最大岛屿的面积\n    \"\"\"\n    if not grid or not grid[0]:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    max_area = 0\n    \n    def dfs(r, c):\n        # 边界检查和水域检查\n        if (r < 0 or r >= rows or c < 0 or c >= cols or \n            grid[r][c] == '0'):\n            return 0\n        \n        # 标记为已访问（变为水域）\n        grid[r][c] = '0'\n        \n        # 递归计算相邻陆地面积\n        area = 1  # 当前格子\n        area += dfs(r + 1, c)  # 下\n        area += dfs(r - 1, c)  # 上\n        area += dfs(r, c + 1)  # 右\n        area += dfs(r, c - 1)  # 左\n        \n        return area\n    \n    # 遍历每个格子\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == '1':\n                current_area = dfs(i, j)\n                max_area = max(max_area, current_area)\n    \n    return max_area\n\n# 测试示例\ngrid = [\n    ['1','1','0','0','0'],\n    ['1','1','0','0','0'], \n    ['0','0','1','0','0'],\n    ['0','0','0','1','1']\n]\n\nresult = maxAreaOfIsland([row[:] for row in grid])  # 复制避免修改原数组\nprint(f\"最大岛屿面积：{result}\")  # 输出：4\n```\n\n**算法分析：**\n\n1. **时间复杂度：** O(m×n)，其中m和n分别是网格的行数和列数。每个格子最多被访问一次。\n\n2. **空间复杂度：** O(m×n)，最坏情况下递归深度为整个网格大小（如全是陆地的蛇形岛屿）。\n\n**边界情况处理：**\n\n```python\n# 空地图\nprint(maxAreaOfIsland([]))  # 输出：0\nprint(maxAreaOfIsland([[]])  # 输出：0\n\n# 全是水域\nprint(maxAreaOfIsland([['0','0'],['0','0']]))  # 输出：0\n\n# 全是陆地  \nprint(maxAreaOfIsland([['1','1'],['1','1']]))  # 输出：4\n```\n\n**算法原理：**\n使用深度优先搜索(DFS)遍历每个陆地格子，计算连通的陆地总面积，记录最大值。",
    "content": "**算法实现：**\n\n```python\ndef maxAreaOfIsland(grid):\n    \"\"\"\n    计算二维网格中最大岛屿的面积\n    \n    Args:\n        grid: 二维字符数组，'1'表示陆地，'0'表示水域\n    \n    Returns:\n        int: 最大岛屿的面积\n    \"\"\"\n    if not grid or not grid[0]:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    max_area = 0\n    \n    def dfs(r, c):\n        # 边界检查和水域检查\n        if (r < 0 or r >= rows or c < 0 or c >= cols or \n            grid[r][c] == '0'):\n            return 0\n        \n        # 标记为已访问（变为水域）\n        grid[r][c] = '0'\n        \n        # 递归计算相邻陆地面积\n        area = 1  # 当前格子\n        area += dfs(r + 1, c)  # 下\n        area += dfs(r - 1, c)  # 上\n        area += dfs(r, c + 1)  # 右\n        area += dfs(r, c - 1)  # 左\n        \n        return area\n    \n    # 遍历每个格子\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == '1':\n                current_area = dfs(i, j)\n                max_area = max(max_area, current_area)\n    \n    return max_area\n\n# 测试示例\ngrid = [\n    ['1','1','0','0','0'],\n    ['1','1','0','0','0'], \n    ['0','0','1','0','0'],\n    ['0','0','0','1','1']\n]\n\nresult = maxAreaOfIsland([row[:] for row in grid])  # 复制避免修改原数组\nprint(f\"最大岛屿面积：{result}\")  # 输出：4\n```\n\n**算法分析：**\n\n1. **时间复杂度：** O(m×n)，其中m和n分别是网格的行数和列数。每个格子最多被访问一次。\n\n2. **空间复杂度：** O(m×n)，最坏情况下递归深度为整个网格大小（如全是陆地的蛇形岛屿）。\n\n**边界情况处理：**\n\n```python\n# 空地图\nprint(maxAreaOfIsland([]))  # 输出：0\nprint(maxAreaOfIsland([[]])  # 输出：0\n\n# 全是水域\nprint(maxAreaOfIsland([['0','0'],['0','0']]))  # 输出：0\n\n# 全是陆地  \nprint(maxAreaOfIsland([['1','1'],['1','1']]))  # 输出：4\n```\n\n**算法原理：**\n使用深度优先搜索(DFS)遍历每个陆地格子，计算连通的陆地总面积，记录最大值。"
  },
  {
    "id": 4,
    "type": "chinese_programming",
    "answer": "**输出结果：**\n\n```\n新班级平均分：88.83333333333333\n优秀学生人数：3\n```\n\n**计算过程详解：**\n\n1. **计算新班级平均分：**\n   - 新学生成绩 = [95, 87, 92, 76, 89, 94]\n   - 总分 = 95 + 87 + 92 + 76 + 89 + 94 = 533\n   - 学生人数 = 6\n   - 平均分 = 533 ÷ 6 = 88.83333333333333\n\n2. **统计优秀学生人数：**\n   - 遍历新学生成绩，统计等级为\"优秀\"的学生\n   - 根据统计等级函数，分数 >= 90 为\"优秀\"\n   - 95 >= 90 → \"优秀\" ✓\n   - 87 < 90 → \"良好\"\n   - 92 >= 90 → \"优秀\" ✓  \n   - 76 < 80 → \"及格\"\n   - 89 < 90 → \"良好\"\n   - 94 >= 90 → \"优秀\" ✓\n   - 优秀学生数 = 3人\n\n**中文编程优缺点分析：**\n\n**优点：**\n1. **可读性强**：变量名和函数名使用中文，更直观易懂\n2. **降低学习门槛**：对中文使用者更友好，减少语言障碍\n3. **业务逻辑清晰**：代码即文档，业务含义一目了然\n4. **本土化适应**：符合中文思维习惯\n\n**缺点：**\n1. **兼容性问题**：部分IDE或系统可能不完全支持中文标识符\n2. **国际化限制**：代码难以在国际团队中共享和维护\n3. **输入效率**：中文输入相比英文较慢\n4. **生态系统**：大部分开源库和文档仍以英文为主\n5. **编码问题**：可能遇到字符编码相关的问题",
    "content": "**输出结果：**\n\n```\n新班级平均分：88.83333333333333\n优秀学生人数：3\n```\n\n**计算过程详解：**\n\n1. **计算新班级平均分：**\n   - 新学生成绩 = [95, 87, 92, 76, 89, 94]\n   - 总分 = 95 + 87 + 92 + 76 + 89 + 94 = 533\n   - 学生人数 = 6\n   - 平均分 = 533 ÷ 6 = 88.83333333333333\n\n2. **统计优秀学生人数：**\n   - 遍历新学生成绩，统计等级为\"优秀\"的学生\n   - 根据统计等级函数，分数 >= 90 为\"优秀\"\n   - 95 >= 90 → \"优秀\" ✓\n   - 87 < 90 → \"良好\"\n   - 92 >= 90 → \"优秀\" ✓  \n   - 76 < 80 → \"及格\"\n   - 89 < 90 → \"良好\"\n   - 94 >= 90 → \"优秀\" ✓\n   - 优秀学生数 = 3人\n\n**中文编程优缺点分析：**\n\n**优点：**\n1. **可读性强**：变量名和函数名使用中文，更直观易懂\n2. **降低学习门槛**：对中文使用者更友好，减少语言障碍\n3. **业务逻辑清晰**：代码即文档，业务含义一目了然\n4. **本土化适应**：符合中文思维习惯\n\n**缺点：**\n1. **兼容性问题**：部分IDE或系统可能不完全支持中文标识符\n2. **国际化限制**：代码难以在国际团队中共享和维护\n3. **输入效率**：中文输入相比英文较慢\n4. **生态系统**：大部分开源库和文档仍以英文为主\n5. **编码问题**：可能遇到字符编码相关的问题"
  },
  {
    "id": 5,
    "type": "code_commenting",
    "answer": "**添加注释后的完整代码：**\n\n```python\ndef quicksort(arr, low, high):\n    \"\"\"\n    快速排序的递归实现\n    \n    Args:\n        arr: 待排序的数组\n        low: 排序范围的起始索引\n        high: 排序范围的结束索引\n    \"\"\"\n    if low < high:  # 确保排序范围有效（至少2个元素）\n        # 获取分区点，将数组分为两部分\n        pi = partition(arr, low, high)\n        \n        # 递归排序左半部分（小于等于基准值的元素）\n        quicksort(arr, low, pi - 1)\n        \n        # 递归排序右半部分（大于基准值的元素）\n        quicksort(arr, pi + 1, high)\n\ndef partition(arr, low, high):\n    \"\"\"\n    分区函数：选择最后一个元素作为基准值，将数组分为两部分\n    \n    Args:\n        arr: 待分区的数组\n        low: 分区范围的起始索引\n        high: 分区范围的结束索引\n    \n    Returns:\n        int: 分区点的索引位置\n    \"\"\"\n    pivot = arr[high]  # 选择最后一个元素作为基准值\n    i = low - 1        # 小于基准值区域的右边界索引\n    \n    # 遍历数组，将小于等于基准值的元素移到左侧\n    for j in range(low, high):\n        if arr[j] <= pivot:  # 当前元素小于等于基准值\n            i += 1  # 扩展小于基准值的区域\n            arr[i], arr[j] = arr[j], arr[i]  # 交换元素\n    \n    # 将基准值放到正确位置（小于基准值区域的右侧）\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    \n    return i + 1  # 返回基准值的最终位置\n\ndef quick_sort(arr):\n    \"\"\"\n    快速排序的外部接口函数\n    \n    Args:\n        arr: 待排序的数组\n    \n    Returns:\n        list: 排序后的数组\n    \"\"\"\n    if len(arr) <= 1:  # 空数组或单元素数组已经有序\n        return arr\n    \n    # 调用递归快速排序函数\n    quicksort(arr, 0, len(arr) - 1)\n    return arr\n\n# 测试代码\narr = [64, 34, 25, 12, 22, 11, 90]\nprint(\"原数组:\", arr)\n\n# 使用copy()避免修改原数组\nsorted_arr = quick_sort(arr.copy())\nprint(\"排序后:\", sorted_arr)\n```\n\n**快速排序基本原理：**\n\n1. **分治策略**：选择一个基准值（pivot），将数组分为两部分：\n   - 左部分：所有小于等于基准值的元素\n   - 右部分：所有大于基准值的元素\n\n2. **递归处理**：对左右两部分分别递归执行快速排序\n\n3. **合并结果**：由于基准值已经在正确位置，不需要额外合并步骤\n\n**时间复杂度分析：**\n\n- **最佳情况**：O(n log n) - 每次分区都能将数组均匀分割\n- **平均情况**：O(n log n) - 随机选择基准值的期望性能\n- **最坏情况**：O(n²) - 每次选择的基准值都是最大或最小值（如已排序数组）\n- **空间复杂度**：O(log n) - 递归调用栈的深度\n\n**算法特点：**\n- 原地排序（in-place）：只需要常数额外空间\n- 不稳定排序：相等元素的相对位置可能改变\n- 实际应用中性能优秀，是很多编程语言内置排序的基础算法",
    "content": "**添加注释后的完整代码：**\n\n```python\ndef quicksort(arr, low, high):\n    \"\"\"\n    快速排序的递归实现\n    \n    Args:\n        arr: 待排序的数组\n        low: 排序范围的起始索引\n        high: 排序范围的结束索引\n    \"\"\"\n    if low < high:  # 确保排序范围有效（至少2个元素）\n        # 获取分区点，将数组分为两部分\n        pi = partition(arr, low, high)\n        \n        # 递归排序左半部分（小于等于基准值的元素）\n        quicksort(arr, low, pi - 1)\n        \n        # 递归排序右半部分（大于基准值的元素）\n        quicksort(arr, pi + 1, high)\n\ndef partition(arr, low, high):\n    \"\"\"\n    分区函数：选择最后一个元素作为基准值，将数组分为两部分\n    \n    Args:\n        arr: 待分区的数组\n        low: 分区范围的起始索引\n        high: 分区范围的结束索引\n    \n    Returns:\n        int: 分区点的索引位置\n    \"\"\"\n    pivot = arr[high]  # 选择最后一个元素作为基准值\n    i = low - 1        # 小于基准值区域的右边界索引\n    \n    # 遍历数组，将小于等于基准值的元素移到左侧\n    for j in range(low, high):\n        if arr[j] <= pivot:  # 当前元素小于等于基准值\n            i += 1  # 扩展小于基准值的区域\n            arr[i], arr[j] = arr[j], arr[i]  # 交换元素\n    \n    # 将基准值放到正确位置（小于基准值区域的右侧）\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    \n    return i + 1  # 返回基准值的最终位置\n\ndef quick_sort(arr):\n    \"\"\"\n    快速排序的外部接口函数\n    \n    Args:\n        arr: 待排序的数组\n    \n    Returns:\n        list: 排序后的数组\n    \"\"\"\n    if len(arr) <= 1:  # 空数组或单元素数组已经有序\n        return arr\n    \n    # 调用递归快速排序函数\n    quicksort(arr, 0, len(arr) - 1)\n    return arr\n\n# 测试代码\narr = [64, 34, 25, 12, 22, 11, 90]\nprint(\"原数组:\", arr)\n\n# 使用copy()避免修改原数组\nsorted_arr = quick_sort(arr.copy())\nprint(\"排序后:\", sorted_arr)\n```\n\n**快速排序基本原理：**\n\n1. **分治策略**：选择一个基准值（pivot），将数组分为两部分：\n   - 左部分：所有小于等于基准值的元素\n   - 右部分：所有大于基准值的元素\n\n2. **递归处理**：对左右两部分分别递归执行快速排序\n\n3. **合并结果**：由于基准值已经在正确位置，不需要额外合并步骤\n\n**时间复杂度分析：**\n\n- **最佳情况**：O(n log n) - 每次分区都能将数组均匀分割\n- **平均情况**：O(n log n) - 随机选择基准值的期望性能\n- **最坏情况**：O(n²) - 每次选择的基准值都是最大或最小值（如已排序数组）\n- **空间复杂度**：O(log n) - 递归调用栈的深度\n\n**算法特点：**\n- 原地排序（in-place）：只需要常数额外空间\n- 不稳定排序：相等元素的相对位置可能改变\n- 实际应用中性能优秀，是很多编程语言内置排序的基础算法"
  }
] 